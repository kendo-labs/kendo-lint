#!/usr/bin/env node
// -*- js -*-

var UTIL = require("util");
var PATH = require("path");
var FS = require("fs");
var KDOCS = require("../lib/parsedocs.js").kendo_apidoc;
var BUNDLE = require("../lib/bundle.js");

var LINT = require("../lib/lint.js");

var OPTIMIST = require("optimist");
var ARGS = OPTIMIST
    .usage("$0 [options] [files]\n\
\n\
If no file names are passed, read from STDIN.\n\
It defaults to reading JavaScript (see --html).")
    .describe("json", "Output results in JSON")
    .describe("html", "Force HTML files")
    .describe("js", "Force JavaScript files")
    .describe("build-kendo", "Build minimal Kendo UI for the specified files.  For this argument, pass the path to your Kendo UI minified files.")
    .describe("o", "Output path for the file generated by --build-kendo")
    .describe("doc", "Search documentation.  E.g. `--doc grid.change`")
    .describe("files", "Read list of files from a file.  Pass nothing for stdin.")
    .boolean("json")
    .boolean("js")
    .boolean("html")
    .boolean("help")
    .boolean("h")
    .string("doc")
    .string("build-kendo")
    .string("o")
    .string("parse-docs")
    .string("files")
    .boolean("_havestack")
    .wrap(80)
    .argv;

if (ARGS.help || ARGS.h) {
    UTIL.puts(OPTIMIST.help());
    process.exit(0);
}

(function(){
    if (ARGS["parse-docs"]) {
        var docdir = ARGS["parse-docs"];
        if (!ARGS._havestack) {
            // relaunch with sufficient stack size
            var CP = require("child_process");
            var p = CP.spawn(process.argv[0], [
                "--stack_size=100000",
                process.argv[1],
                "--parse-docs", docdir,
                "--_havestack"
            ], {
                cwd: docdir
            });
            p.stdout.on("data", function(data){ UTIL.print(data) });
            p.stderr.on("data", function(data){ UTIL.print(data) });
            p.stdout.on("end", function(){
                console.log("*** Done");
                process.exit(0);
            });
            return;
        }
        var glob = require("glob");
        var pattern = PATH.join("api", "{web,dataviz,mobile,framework}", "**", "*.md");
        glob(pattern, function(err, files){
            files.forEach(function(filename){
                console.log("Parsing API doc: " + filename);
                KDOCS.parse(filename);
            });
            var output = PATH.join(__dirname, "..", "lib", "api.json");
            FS.writeFileSync(output, JSON.stringify(KDOCS.components), { encoding: "utf8" });
            console.log("Wrote " + output);
        });
        return;
    }

    function getType(file) {
        if (!file) return "js";
        if (typeof file == "object") {
            return file.type || getType(file.file);
        }
        if (ARGS.js) return "js";
        if (ARGS.html) return "html";
        if (/\.(aspx?)$/i.test(file))
            return "asp";
        return (/\.(html?|cshtml|master|ascx|php)$/i.test(file) ? "html"
                : /\.js$/i.test(file) ? "js"
                : null);
    }

    function getPath(file) {
        if (typeof file == "string") return file;
        return file.file;
    }

    function doFile(code, file, callback) {
        var results = [];
        switch (getType(file)) {
          case "js":
            LINT.lint_javascript_file(code, getPath(file), results);
            break;
          case "html":
            LINT.lint_html_file(code, getPath(file), results);
            break;
          case "asp":
            LINT.lint_html_file(code, getPath(file), results, { asp: true });
            break;
          default:
            return callback(new Error("I don't know how to parse " + getPath(file)));
        }
        return callback(null, results);
    }

    function readFile(filename, callback) {
        if (filename) {
            FS.readFile(filename, { encoding: "utf8" }, callback);
        } else {
            var input = "";
            process.stdin.resume();
            process.stdin.setEncoding("utf8");
            process.stdin
                .on("data", function(chunk){ input += chunk })
                .on("end", function(){ callback(null, input) });
        }
    }

    if (ARGS.files) {
        readFile(ARGS.files === true ? null : ARGS.files, function(err, data){
            var files = JSON.parse(data);
            moveOn(files);
        });
    } else {
        var files = ARGS._.slice();
        if (files.length == 0) files.push(null); // read from STDIN
        moveOn(files);
    }

    function moveOn(files) {

        if (ARGS["build-kendo"]) {
            var kendo_dir = ARGS["build-kendo"];
            var js_files = [], html_files = [], asp_files = [];
            files.forEach(function(file){
                switch (getType(file)) {
                  case "html" : html_files.push(getPath(file)); break;
                  case "asp"  : asp_files.push(getPath(file)); break;
                  case "js"   : js_files.push(getPath(file)); break;
                  default:
                    UTIL.error("Unsupported file type: " + getPath(file));
                }
            });
            var usage = BUNDLE.widget_usage({
                js_files   : js_files,
                html_files : html_files,
                asp_files  : asp_files,
                category   : BUNDLE.kendo_category(kendo_dir),
            });
            if (usage.errors && usage.errors.length > 0) {
                UTIL.error(JSON.stringify(usage.errors, null, 2));
            }
            var code = BUNDLE.build_kendo({
                components : usage.components,
                kendo_dir  : kendo_dir,
            });
            if (ARGS.o) {
                FS.writeFileSync(ARGS.o, code, "utf8");
            } else {
                UTIL.puts(code);
            }
            return;
        }

        KDOCS.initialize();

        if (ARGS.doc) {
            var doc = require("../lib/docs.js").search(ARGS.doc);
            UTIL.puts(JSON.stringify(doc, null, 2));
            return;
        }

        var results = [], count = files.length;

        files.forEach(function(file){
            readFile(getPath(file), function(err, code){
                if (err) {
                    UTIL.error(err + "");
                    process.exit(1);
                }
                doFile(code, file, function(err, ret){
                    results.push.apply(results, ret);
                    if (!ARGS.json) {
                        ret.forEach(function(err){
                            if (err.line != null && err.col != null) {
                                UTIL.puts(err.filename + "[" + err.line + "," + err.col + "]: " + err.message);
                            }
                            else if (err.line != null) {
                                UTIL.puts(err.filename + "[" + err.line + "]: " + err.message);
                            }
                            else {
                                UTIL.puts(err.filename + ": " + err.message);
                            }
                        });
                    }
                    if (--count == 0) finished();
                });
            });
        });

        function finished() {
            if (ARGS.json) {
                UTIL.print(JSON.stringify(results, null, 2));
            }
        }

    }

})();
